# Array와 List란?

### ⭐️자료구조란 무엇인가?

- 사전적인 의미는 자료(Data)의 집합의 의미하며, 각 원소들이 논리적으로 정의된 규칙에 의해 나열되며 자료에 대한 처리를 효율적으로 수행할 수 있도록 자료를 구분하여 표현한 것
- 다양한 자료구조가 존재하고, 이를 활용하는 목적은 명확하다. 자료를 더 효율적으로 저장하고, 관리하기 위해 사용하며, 잘 선택된 자료구조는 실행시간을 단축시켜주거나 메모리 용량의 절약을 이끌어 낼 수 있습니다.

### ❓자료구조의 선택 기준

- 자료의 처리 시간
- 자료의 크기
- 자료의 활용 빈도
- 자료의 갱신 정도
- 프로그램의 용이성

---

## Array란?

### Array의 개념적 설명

- 배열(Array)은 모든 언어에서 사용되는 가장 기본적인 메모리 공간이다.
- 배열(Array)은 **자료형이 같은 둘 이상의 값**을 저장할 수 있다.
    - JavaScript의 경우에는 배열의 자료형이 달라도 저장할 수 있다. 다만 이 경우 동일한 배열 내에 자료형을 달리 하는 작업을 하기위해 엔진이 컨버팅을 수행하게 되는데 컨버팅의 횟수만큼 작업 효율이 감소하므로 성능 고도화를 위해서는 자료형이 지정된 Typed Array를 사용할것을 권장한다
        - JavaScript의 Typed Array는 Float64Array, Int32Array 등이 있다.
        - 이러한 타입의 불확실성은 오류를 최소화 하려는 자바스크립트의 철학에서 비롯된 것이라 알려져있다.
    - 원시(Primitive - int, double 등) 타입, 또는 객체(Object, non-Primitive) 타입으로 배열을 선언하여 해당 특정 타입의 값을 공간의 크기에 따라 저장할 수 있다.
- 배열(Array)은 여타 Class형 객체들과 달리 특별한 형태로 구현되어 있다. 별도의 Source Code를 확인할 수 없으며 동적으로 사용자가 구현하면 내부적으로 Class가 생성되는 방식이다.
- 자바(Java)에서 최상위 Class인 Object를 직접 상속받아서 구현되기 때문에 아래와 같이 Class의 이름을 확인해볼 수는 있다.(즉, 배열의 바로 상위 Class는 Object이다.)
    
    ![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled.png)
    
    - `Array` permits widening conversions to occur during a get or set operation, but throws an `IllegalArgumentException` if a narrowing conversion would occur.
    - **Array는 get 또는 set 작업 중에 발생하는 확대 변환을 허용하지만 축소 변환이 발생할 경우 IllegalArgumentException을 발생시킨다는 뜻이다.**
        - 해당 예외는 메소드가 잘못되었거나 부적절한 요소로 인해 나타나는 예외이다.
    
    ![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%201.png)
    

---

### Array의 시간 복잡도 Case를 알아보기에 앞서

<aside>
💡 **시간 복잡도란?**

어떤 알고리즘을 수행하는 데 걸리는 시간을 설명하는 계산 복잡도를 의미하며, 계산 복잡도를 표기하는 대표적인 방법으로 Big-O 표기법을 사용한다.

</aside>

**▶️시간 복잡도 예시 1: O(1)**

```java
if(n%2 == 0) {
    System.out.println("짝수");
} else {
    System.out.println("홀수");
}

위 예제는 입력한 n이 짝수면 한 단계에 걸쳐 수행이 완료되
홀수면 두 단계에 걸쳐 수행이 완료되는 코드이다.

하지만 Big-O에서는 이것을 O(1), O(2)로 나누지 않고 O(1)로 통칭한다.

이러한 상수들은 대부분 O(1)이라고 생각하면 된다.
```

**▶️시간 복잡도 예시2: O(n)**

```java

for(int i=0; i<n; i++) {
    System.out.println(n);
}

반복문을 이용해 n번 반복한다면 이는 Big-O 표기법으로 O(n)이라 나타낼 수 있다.
n의 값에 따라 처리수도 1:1 비례해서 늘어난다.

-> 이러한 알고리즘을 선형 시간 알고리즘이라 부른다.
정렬되지 않은리스트에서 최대 또는 최솟값을 찾는 경우가 해당되며
모든 입렵값을 적어도 한 번 이상은 살펴봐야 한다.

상황에 적합한 자료구조를 택하는 것과 같은 맥락으로 적합한 알고리즘을 적용하는 것도 중요한 이유이다
  * 메모리를 얼마나 효율적으로 사용하는지가 갈리므로
```

**▶️시간 복잡도 예시3: O(n²)**

```java
for(int i=0; i<n; i++) {
    for(int j=0; j<n; j++) {
        System.out.println(n * j);
    }
}

2번의 경우가 두 번 겹쳐져 있으면 된다고 생각하면 쉬울것 같다.
즉 반복문이 2번 겹쳐져있는 케이스.
```

**▶️시간 복잡도 예시4: O(n³)**

```java
for(int i=0; i<n; i++) {
    for(int j=0; j<n; j++) {
        for(int k=0; k<n; k++) {
            System.out.println(n * j + k);
        }
    }
}
```

**▶️시간 복잡도 예시5: O(nm)**

```java
for(int i=0; i<n; i++) {
    for(int j=0; j<m; j++) {
        System.out.println(n * m);
    }
}

이중 for문을 도는 3번 예시와 같아보이지만 엄연히 다르다.
첫번째 for문이 99999999여도 두번째 for문이 1일수 있기 때문이다.
```

**▶️시간 복잡도 예시6: O(2ⁿ)**

```java
public static int pibo(int n) {
    if (n == 0) return 0;
    else if (n == 1) return 1;
 
    return pibo(n - 1) + pibo(n - 2);
}

위 코드는 피보나치수열을 구현한 것이다.
pibo(n)을 호출하면 pibo(n-1)과 pibo(n-2)가 호출된다.
그리고 이 호출 작업은 총 n번 반복되기 때문에 이를 Big-O 표기법으로 나타내면 O(2ⁿ)이 된다.
```

**▶️시간 복잡도 예시7: O(logn)**

```java
public static int binarySeacrh(int[] num, int target, int low, int high) {
    int mid = (low + high) / 2;
		
    if(target == num[mid]) return mid;
    else if(target < num[mid]) return binarySeacrh(num, target, low, mid-1);
    else return binarySeacrh(num, target, mid+1, high);
}
위 코드는 이진 탐색 기법을 코드로 구현한 것이다.
탐색을 해나갈수록 탐색해야 할 데이터가 절반으로 뚝뚝 떨어지기 때문에
이를 Big-O 표기법으로 나타내면 O(logn)이 된다.
```

---

### 배열의 시간 복잡도 경우의 수

 *** 전술한 시간 복잡도 예시중 1, 2번 케이스 내에서 끝난다**

1. **임의의 위치에 있는 원소를 확인하거나 변경하는 연산 : O(1)**
    
    메모리 상에 일렬로 나열되어 있으니 배열의 **시작 주소에서 k칸 만큼 더하면 k번째 원소를 찾을 수 있다.**
    
    k번째 원소의 위치 = 시작주소 + (1칸이 차지하는 주소 X k)이므로 단순 사칙연산 계산에 의해 O(1)만에 k번째 원소를 찾을 수 있다.
    
    k번째 원소 위치를 찾았다면 원소를 확인하거나 변경해주면 된다.
    
    ![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%202.png)
    

1. **배열의 가장 끝에 원소 추가하기 : O(1)**
    
    배열의 끝 주소 = 시작 주소 + (1칸이 차지하는 주소 X 배열 길이)
    
    위 수식을 통해 배열의 끝 주소를 찾고, 배열의 길이를 1 증가시킨 후, 추가할 원소 데이터를 저장하면 된다.
    
    이것도 시간복잡도는 O(1)이다.
    

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%203.png)

1. **배열의 가장 끝 원소 삭제하기 : O(1)의 시간이 걸림**
    
    위에서 알아본 배열의 가장 끝에 원소 추가하기와 비슷하게 배열의 끝 주소를 찾고, 배열의 길이를 1만큼 줄이면 되므로 시간복잡도는 O(1)이다.
    

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%204.png)

1. **임의의 위치에 원소를 추가하기 : O(N)의 시간이 걸림**
    
    임의의 위치에 원소를 새로 추가해서 끼워넣으려면 그 뒤에 존재하는 모든 원소들을 한 칸씩 뒤로 밀어야 한다.
    

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%205.png)

추가하려는 위치가 배열의 끝과 가까울수록 그 뒤에 존재하는 원소의 개수가 적어져 뒤로 밀어내는 연산의 수도 줄어들고, 처음과 가까울수록 늘어난다.

1. **임의의 위치에 있는 원소를 제거하기 : O(N)의 시간이 걸림**
    
    이 연산도 임의의 위치에 원소를 추가하는 것과 비슷하게 수행된다.
    
    임의의 위치에 있는 원소를 삭제하면 그 뒤에 존재하는 모든 원소들을 한 칸씩 앞으로 당겨와야 한다.
    
    왜 굳이 앞으로 당겨와야 할까?
    
    배열의 정의 상 배열은 메모리 상에 데이터(원소)를 **연속하게 배치한 자료구조**이기 때문이다.
    

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%206.png)

<aside>
💡 **정리

배열은 처음이나 끝 위치에서 요소의 변경이 일어났을 시 O(1)의 시간 복잡도를 가지고
”임의의 위치"에 요소의 변경이 발생했을 시 O(n)의 시간 복잡도를 가진다.**

</aside>

---

## **Array(배열)의 장/단점**

위에서 알아본 내용을 종합하여 Array(배열)의 장점 및 단점을 정리해보자.

- **장점**
    - Index를 통해 원소에 O(1) 시간복잡도 만에 빠르게 접근할 수 있다.
- **단점**
    - 새로운 원소를 삽입하고 삭제하는데 O(N) 시간복잡도가 걸려 느리다.
    - 연속된 메모리 상에 원소들이 존재하므로 처음 배열을 선언한 크기만큼 데이터를 저장하지 않는다면 메모리 낭비가 발생한다.
        
        예를 들어, 배열 선언시 배열의 크기를 10으로 선언했는데 3개의 원소에만 데이터를 저장했을 경우 7개의 원소는 비어있게 되므로 7개 원소가 차지하는 메모리 공간만큼 낭비가 발생하게 된다.
        
- **배열을 언제 사용해야 좋을까?**
    
    데이터 개수가 확실하게 정해져 있을 때 데이터 저장을 위한 자료구조로 선택하면 좋다.
    
    또한, 삽입/삭제 작업이 적을 때 사용하면 좋다.
    
    마지막으로 배열에 저장된 데이터를 검색하는 작업이 많을 때 사용하면 좋다.(인덱스로 빠르게 검색 가능)
    

---

### List란?

### List의 개념적 설명

**리스트란**, 자료를 순서대로 한 줄로 저장하는 **선형 자료구조**이다.

- head: 리스트에서 제일 처음 데이터를 head 라고 한다.
- tail: 리스트에서 제일 마지막 데이터를 tail 이라고 한다.

List는 크게 ArrayList와 LinkedList가 있는데, ArrayList는 자료구조의 특성이 Array와 더 유사하므로 LinkedList에 대하여 알아보자

---

### ****연결 리스트 (Linked List) 의 종류****

**1. Simple Linked List(단순 연결 리스트)**

- **단순 연결 리스트**란, 연결의 형태가 한쪽 방향으로 전개되고 시작과 끝이 분명히 존재하는 리스트를 말한다.

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%207.png)

**2. Doubly Linked List(이중/양방향 연결 리스트)**

- **이중/양방향 연결 리스트**란, 노드가 양쪽 방향으로 연결된 구조의 리스트를 말한다. 즉, 왼쪽 노드가 오른쪽 노드를 가리킴과 동시에 오른쪽 노드도 왼쪽 노드를 가리키는 구조이다.

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%208.png)

**3. Circular Linked List(원형/환형 연결 리스트)**

![Untitled](Array%E1%84%8B%E1%85%AA%20List%E1%84%85%E1%85%A1%E1%86%AB%20c77d2926929742b2961e966656c60e32/Untitled%209.png)

---

### List의 장단점

### **List의 장점**

1. Insert/Delete동작에서 각 Element가 가리키는 주소만 변경하면 되기 때문에 효율적이다.

2. 크기가 고정적이지 않기 때문에 Array와 같은 불편함이 없다.

### **List의 단점**

1. 각 Element가 다른 Element를 가리키는 형태이기 때문에 Reading작업에 비효율적이다.

2. 다른 Element의 주소를 저장하기 위해 추가적인 메모리 공간 사용이 필요하다.

---

### List의 시간 복잡도

| 연산 | 시간 복잡도 |
| --- | --- |
| 접근 | O(n) |
| 탐색 | O(n) |
| 삽입 | O(1) |
| 삭제 | O(1) |
| 원하는 노드에 접근/탐색 + 삽입 | O(n+1) |
| 원하는 노드에 접근/탐색 + 삭제 | O(n+1) |
| 가장 앞에 접근 + 삽입 | O(1+1) |
| 가장 앞에 접근 + 삭제 | O(1+1) |
| 가장 뒤에 접근 + 삽입 | O(1+1) |
| 뒤에서 두번째 노드(tail노드 전 노드)접근 + 삭제 | O(n+1) |